sequenceDiagram
    autonumber
    %% PARTICIPANTS
    participant Issuers as Issuing CAs<br>(AdminCA and/or UserCA)
    participant NodeA as Node A (Prover)
    participant NodeB as Node B (Verifier)
    Note over NodeA, NodeB: SECURITY PROFILE (STRICT):<br>MUST use ML-DSA-87 for Node identity signatures,<br>MUST use X25519Kyber768 for session key exchange,<br>MUST use PQ-hybrid TLS suites only,<br>NO downgrade/fallback to weaker profile.
    Note over NodeA, NodeB: REVOCATION STATUS:<br>Revocation protocol details are not yet fully specified in this diagram and will be specified and implemented afterwards.
    Note over Issuers: UserCA ANCHORING:<br>Every UserCA MUST be anchored by an AdminCA signature.<br>Anchoring/signing is handled by trusted frontend enrollment/admin flows and remains high-level in this spec.<br>If the anchor AdminCA is revoked/removed, the UserCA becomes untrusted.

    %% ==========================================
    %% PHASE 1: ISSUANCE (Offline / Bootstrap)
    %% Describes how a node gets its initial identity.
    %% ==========================================
    Note over NodeA, Issuers: PHASE 1: IDENTITY BOOTSTRAP (Offline)
    
    NodeA->>NodeA: 1. Generate Persistent KeyPair<br>(NodePubKey + NodePrivKey)<br>Algo: ML-DSA-87
    
    NodeA->>Issuers: 2. Submit NodePubKey + proof of ownership
    
    Note right of Issuers: POLICY CHECK:<br>1. Validate Node Hardware/Request<br>2. Determine Permissions (Admin and/or User)
    
    Issuers->>Issuers: 3. Calculate IssuerCAHash<br>(Unique SHA-256 ID of each CA Root Key)
    
    Issuers->>Issuers: 4. Construct one or more NodeCert Payloads:<br>{ CertVersion, NodePubKey, IssuerCAHash,<br>ValidFrom, ValidUntil, Serial, RoleClaims,<br>CertNonce }
    
    Note right of Issuers: SIGNING:<br>NodeCert/UserCA signing is handled by trusted frontend flows.<br>This diagram keeps signing details intentionally high-level.
    Issuers->>Issuers: 5. For each cert: sign NodeCert payload (high-level)
    
    Issuers->>NodeA: 6. Return Signed NodeCert bundle (+ CA signatures)
    Note left of NodeA: STORAGE:<br>Node persists NodeCert bundle + NodePrivKey.<br>NodePrivKey never leaves secure boundary.

    %% ==========================================
    %% PHASE 2: DELEGATION (Startup)
    %% Describes how the node prepares for TLS without exposing its long-term key.
    %% ==========================================
    Note over NodeA: PHASE 2: SESSION DELEGATION (Startup/Rotation)
    
    NodeA->>NodeA: 1. Generate Ephemeral Session KeyPair<br>Algo: X25519Kyber768 (Hybrid PQ)
    
    Note left of NodeA: DELEGATION:<br>The persistent NodePrivKey signs the<br>ephemeral SessionPubKey. This links<br>the Identity to the Transport.
    
    NodeA->>NodeA: 2. Create X.509 Template (Leaf)<br>Subject = SessionPubKey, Short TTL
    NodeA->>NodeA: 3. Sign X.509 using SessionPrivKey

    %% ==========================================
    %% PHASE 3: THE HANDSHAKE (Runtime)
    %% The actual network connection.
    %% ==========================================
    Note over NodeA, NodeB: PHASE 3: SECURE CONNECTION (Runtime)
    Note over NodeA, NodeB: Each node-to-node connection MUST be independently authenticated and encrypted via transport security.
    
    NodeA->>NodeB: TLS ClientHello (CipherSuites: PQ-Hybrid,<br>SupportedGroups: X25519Kyber768)
    NodeB->>NodeA: TLS ServerHello
    
    Note right of NodeA: STEP A: TRANSPORT SECURITY<br>Prove ownership of the Ephemeral Session Key.
    NodeA->>NodeB: Send X.509 Cert (Contains SessionPubKey)
    NodeA->>NodeB: TLS CertificateVerify (Signed by SessionPrivKey)
    
    Note right of NodeB: TLS CHECKS:<br>1. Peer owns SessionPrivKey<br>2. Negotiated suite/group match strict profile<br>3. Any downgrade => fail closed
    
    NodeA->>NodeA: Build DelegationProof from this active handshake:<br>{ TLSCertPubKeyHash, TLSExporterBinding, TLSTranscriptHash,<br>X509Fingerprint, NodeCertBundleHash, NotBefore, NotAfter }<br>where TLSTranscriptHash covers full handshake through TLS Finished
    NodeA->>NodeA: Derive TLSExporterBinding using label<br>"EXPORTER_OUROBOROS_NODE_DELEGATION_V1"<br>and context CanonicalSerialize(DelegationProof minus TLSExporterBinding)
    NodeA->>NodeA: Sign DelegationProof:<br>DelegationSig = Sign(CTX_NODE_DELEGATION_V1 || CanonicalSerialize(DelegationProof))
    Note right of NodeA: STEP B: IDENTITY ASSERTION<br>Send the handshake-bound authorization proof.
    NodeA->>NodeB: Send NodeCertBundle + CASignatures + DelegationProof + DelegationSig
    
    %% ==========================================
    %% PHASE 4: VALIDATION
    %% The critical security logic.
    %% ==========================================
    Note over NodeB: PHASE 4: CHAIN VALIDATION
    
    rect rgb(30, 30, 30)
        Note right of NodeB: CHECK 1: ISSUER DISCOVERY
        NodeB->>NodeB: Read each cert's IssuerCAHash
        NodeB->>NodeB: Lookup issuer public keys in local trust store
        
        alt No known issuer for any cert
            NodeB->>NodeA: REJECT: "Unknown CA"
        else At least one issuer found
            NodeB->>NodeB: Continue with known issuers
        end
    end

    rect rgb(50, 30, 30)
        Note right of NodeB: CHECK 2: VALIDITY / REVOCATION / FRESHNESS
        NodeB->>NodeB: For each cert: verify now in [ValidFrom, ValidUntil]
        NodeB->>NodeB: For each cert: revocation checks are TODO until revocation protocol spec lands
        NodeB->>NodeB: For each issuer: revocation freshness model is TODO and will be defined later
        alt No valid cert remains
            NodeB->>NodeA: REJECT: "No Valid Cert"
        else One or more certs remain valid
            NodeB->>NodeB: Continue with valid cert subset
        end
    end
    
    rect rgb(20, 50, 20)
        Note right of NodeB: CHECK 3: AUTHORITY VERIFICATION
        NodeB->>NodeB: For each candidate cert: verify CA signature<br>Input: CTX_NODE_ADMISSION_V1 || NodeCert
        NodeB->>NodeB: Verify all valid certs bind to same NodePubKey/NodeID
        Note right of NodeB: PASS: "NodePubKey is authorized by one or more valid CAs."
    end

    rect rgb(20, 50, 20)
        Note right of NodeB: CHECK 4: DELEGATION BINDING
        NodeB->>NodeB: Extract NodePubKey from verified NodeCert
        NodeB->>NodeB: Verify DelegationSig using NodePubKey<br>Input: CTX_NODE_DELEGATION_V1 || DelegationProof
        NodeB->>NodeB: Check DelegationProof.TLSCertPubKeyHash == hash(TLS Cert SPKI)
        NodeB->>NodeB: Check DelegationProof.X509Fingerprint == presented X.509
        NodeB->>NodeB: Check DelegationProof.NodeCertBundleHash == hash(CanonicalNodeCertBundle(NodeCertBundle))
        NodeB->>NodeB: CanonicalNodeCertBundle = deterministic CBOR (RFC 8949 core deterministic encoding) over canonical NodeCert array sorted by NodePubKey bytes, then Serial bytes
        Note right of NodeB: PASS: "Identity key explicitly delegated<br>this exact transport key and cert."
    end

    rect rgb(20, 50, 20)
        Note right of NodeB: CHECK 5: REPLAY / UKS DEFENSE
        NodeB->>NodeB: Verify DelegationProof.NotAfter is short-lived
        NodeB->>NodeB: Check DelegationProof.TLSExporterBinding == TLS exporter value using label "EXPORTER_OUROBOROS_NODE_DELEGATION_V1" and context CanonicalSerialize(DelegationProof minus TLSExporterBinding)
        NodeB->>NodeB: Check DelegationProof.TLSTranscriptHash == full handshake transcript hash through TLS Finished
        alt Replay or Unknown-Key-Share detected
            NodeB->>NodeA: REJECT: "Replay/UKS"
        else Fresh and bound
            NodeB->>NodeB: Continue
        end
    end
    
    alt All Checks Pass
        NodeB->>NodeB: Derive effective scope from valid cert set<br>If any Admin cert is valid then ScopeAdmin<br>Else if one or more User certs are valid then ScopeUser and owners are valid UserCA hashes
        NodeB->>NodeB: For User-only nodes: authorize data requests only if owner in allowed owner set
        NodeB->>NodeB: Recompute effective rights whenever cert validity/revocation changes
        NodeB->>NodeA: ACCEPT CONNECTION
    else Any Failure
        NodeB->>NodeA: CLOSE CONNECTION (Bad Certificate)
    end