package main

import (
	"bytes"
	"context"
	"crypto/aes"
	"crypto/cipher"
	crand "crypto/rand"
	"crypto/sha512"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log/slog"
	"math/rand"
	"mime/multipart"
	"net/http"
	"net/textproto"
	"os"
	"path/filepath"
	"sync"
	"time"

	cryptHash "github.com/i5heu/ouroboros-crypt/hash"
	keys "github.com/i5heu/ouroboros-crypt/keys"
	ouroboros "github.com/i5heu/ouroboros-db"
)

func main() {
	// parameters
	threads := flag.Int("threads", 100, "number of threads to create")
	messages := flag.Int("messages", 1000, "messages per thread to create")
	path := flag.String("path", "./data", "data directory (where ouroboros.key will live)")
	httpMode := flag.Bool("http", false, "POST data via API server instead of writing DB directly")
	serverAddr := flag.String("server", "http://localhost:8083", "server address when using HTTP mode")
	otkKeyB64 := flag.String("otk-key", "", "base64 one-time key generated by server (only for HTTP mode)")
	otkNonceB64 := flag.String("otk-nonce", "", "base64 one-time key nonce generated by server (only for HTTP mode)")
	randSeed := flag.Int64("seed", time.Now().UnixNano(), "rand seed - useful for reproducible trees")
	flag.Parse()

	// setup logger
	logger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{AddSource: true}))
	slog.SetDefault(logger)

	// create key if missing
	keyFile := filepath.Join(*path, "ouroboros.key")
	if _, err := os.Stat(keyFile); os.IsNotExist(err) {
		slog.Info("no keyfile found - generating new one", "path", keyFile)
		a, err := keys.NewAsyncCrypt()
		if err != nil {
			slog.Error("failed to generate keypair", "error", err)
			os.Exit(1)
		}
		if err := a.SaveToFile(keyFile); err != nil {
			slog.Error("failed to save key file", "error", err)
			os.Exit(1)
		}
	} else if err != nil {
		slog.Error("failed to stat keyfile", "error", err)
		os.Exit(1)
	}

	// init DB - we construct DB only when using direct DB mode (default)
	var db *ouroboros.OuroborosDB
	ctx := context.Background()
	if !*httpMode {
		cfg := ouroboros.Config{Paths: []string{*path}, MinimumFreeGB: 1}
		var err error
		db, err = ouroboros.New(cfg)
		if err != nil {
			slog.Error("failed to construct DB", "error", err)
			os.Exit(1)
		}

		ctx := context.Background()
		if err := db.Start(ctx); err != nil {
			slog.Error("failed to start DB", "error", err)
			os.Exit(1)
		}
	}

	// seeded rand
	rand.Seed(*randSeed)

	// If httpMode is true, we must obtain browser auth token/kv hash before writing
	var httpAuthData *httpAuth
	if *httpMode {
		if *otkKeyB64 == "" || *otkNonceB64 == "" {
			slog.Error("http mode requires -otk-key and -otk-nonce (base64)")
			os.Exit(1)
		}
		var err error
		httpAuthData, err = initHTTPAuth(*serverAddr, *otkKeyB64, *otkNonceB64)
		if err != nil {
			slog.Error("failed to initialize HTTP auth", "error", err)
			os.Exit(1)
		}
	}

	// create threads concurrently
	var wg sync.WaitGroup
	startTime := time.Now()

	wg.Add(*threads)
	for i := 0; i < *threads; i++ {
		go func(tIdx int) {
			defer wg.Done()
			if *httpMode {
				createThreadHTTP(*serverAddr, httpAuthData, tIdx, *messages)
			} else {
				createThread(ctx, db, tIdx, *messages)
			}
		}(i)
	}
	wg.Wait()

	duration := time.Since(startTime)
	fmt.Printf("Seeding completed: %d threads x %d messages in %s\n", *threads, *messages, duration.String())

	if db != nil {
		if err := db.CloseWithoutContext(); err != nil {
			slog.Warn("error closing DB", "error", err)
		}
	}
}

// createThread builds a root node followed by a forest of messages that are
// parented to previous nodes in the same thread to build nested levels.
func createThread(ctx context.Context, db *ouroboros.OuroborosDB, threadIdx, messages int) {
	// Each thread has a root message
	rootContent := []byte(fmt.Sprintf("Thread %d root", threadIdx))
	rootHash, err := db.StoreData(ctx, rootContent, ouroboros.StoreOptions{MimeType: "text/plain; charset=utf-8"})
	if err != nil {
		slog.Error("failed to create thread root", "thread", threadIdx, "error", err)
		return
	}

	// keep a slice of created keys within this thread so new messages can link to them
	var keys []cryptHash.Hash
	keys = append(keys, rootHash)

	// Decide a maximum extra depth for this thread randomly to introduce variance
	maxDepth := rand.Intn(8) + 1 // 1..8

	// Create messages
	for m := 1; m < messages; m++ {
		// choose a parent; sometimes choose the latest to create deep chains, sometimes random earlier for branching
		choice := rand.Intn(100)
		var parent cryptHash.Hash
		if choice < 60 { // bias towards recent nodes
			parent = keys[len(keys)-1]
		} else if choice < 90 { // randomly select within recent half
			idx := len(keys) - 1 - rand.Intn(min(len(keys), maxDepth))
			parent = keys[idx]
		} else { // pick a random node from earlier
			parent = keys[rand.Intn(len(keys))]
		}

		// create content; sometimes make it binary
		var content []byte
		var mime string
		if rand.Intn(100) < 10 { // 10% binary
			content = []byte{0xde, 0xad, byte(threadIdx & 0xff), byte(m & 0xff)}
			mime = "application/octet-stream"
		} else {
			depth := computeDepth(keys, parent)
			content = []byte(fmt.Sprintf("Thread %d message %d depth %d parent %s", threadIdx, m, depth, parent.String()))
			mime = "text/plain; charset=utf-8"
		}

		opts := ouroboros.StoreOptions{Parent: parent, MimeType: mime}
		hash, err := db.StoreData(ctx, content, opts)
		if err != nil {
			slog.Warn("failed to store message", "thread", threadIdx, "index", m, "error", err)
			return
		}

		// append to the list of keys in this thread for future parent selection
		keys = append(keys, hash)
	}
}

// --- HTTP seeding helpers and types
type httpAuth struct {
	kvHashHex    string
	kvHashBase64 string
	browserKey   []byte
	client       *http.Client
}

// initHTTPAuth uses the given server's OTK and nonce to register a BrowserKey for later requests.
func initHTTPAuth(serverAddr, otkKeyB64, otkNonceB64 string) (*httpAuth, error) {
	// decode OTK
	otkKey, err := base64.StdEncoding.DecodeString(otkKeyB64)
	if err != nil {
		return nil, fmt.Errorf("failed to decode otk key: %w", err)
	}
	otkNonce, err := base64.StdEncoding.DecodeString(otkNonceB64)
	if err != nil {
		return nil, fmt.Errorf("failed to decode otk nonce: %w", err)
	}

	// Browser key: pick a random 32-byte key
	browserKey := make([]byte, 32)
	if _, err := crand.Read(browserKey); err != nil {
		return nil, fmt.Errorf("failed to generate browser key: %w", err)
	}

	// encrypt browserKey using OTK key/nonce with AES-GCM
	ciphertext, err := encryptAESGCM(otkKey, otkNonce, browserKey)
	if err != nil {
		return nil, fmt.Errorf("failed to encrypt browser key: %w", err)
	}

	reqBody := map[string]string{
		"data":   "b64:" + base64.StdEncoding.EncodeToString(ciphertext),
		"sha512": fmt.Sprintf("%x", sha512.Sum512(otkKey)),
	}
	body, _ := json.Marshal(reqBody)
	resp, err := http.Post(serverAddr+"/authProcess", "application/json", bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("failed to POST authProcess: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		b, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("authProcess request failed: status=%d body=%s", resp.StatusCode, string(b))
	}

	var respBody struct {
		Status    string `json:"status"`
		KeyKvHash string `json:"keyKvHash"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&respBody); err != nil {
		return nil, fmt.Errorf("failed to decode authProcess response: %w", err)
	}

	// convert hex hash to raw bytes and base64 encode for header
	kvBytes, err := hex.DecodeString(respBody.KeyKvHash)
	if err != nil {
		return nil, fmt.Errorf("failed to decode keyKvHash hex: %w", err)
	}
	kvBase64 := base64.StdEncoding.EncodeToString(kvBytes)

	return &httpAuth{kvHashHex: respBody.KeyKvHash, kvHashBase64: kvBase64, browserKey: browserKey, client: http.DefaultClient}, nil
}

// createThreadHTTP uses server API to create the thread and messages using the given auth.
func createThreadHTTP(serverAddr string, auth *httpAuth, threadIdx, messages int) {
	// create root message
	rootContent := []byte(fmt.Sprintf("Thread %d root", threadIdx))
	rootKey, err := postDataHTTP(serverAddr, auth, rootContent, "text/plain; charset=utf-8", "", nil)
	if err != nil {
		slog.Error("failed to create thread root (http)", "thread", threadIdx, "error", err)
		return
	}

	var keys []string
	keys = append(keys, rootKey)
	maxDepth := rand.Intn(8) + 1

	for m := 1; m < messages; m++ {
		var parent string
		choice := rand.Intn(100)
		if choice < 60 {
			parent = keys[len(keys)-1]
		} else if choice < 90 {
			idx := len(keys) - 1 - rand.Intn(min(len(keys), maxDepth))
			parent = keys[idx]
		} else {
			parent = keys[rand.Intn(len(keys))]
		}

		var content []byte
		var mime string
		if rand.Intn(100) < 10 {
			content = []byte{0xde, 0xad, byte(threadIdx & 0xff), byte(m & 0xff)}
			mime = "application/octet-stream"
		} else {
			depth := computeDepthHTTP(keys, parent)
			content = []byte(fmt.Sprintf("Thread %d message %d depth %d parent %s", threadIdx, m, depth, parent))
			mime = "text/plain; charset=utf-8"
		}

		key, err := postDataHTTP(serverAddr, auth, content, mime, parent, nil)
		if err != nil {
			slog.Warn("failed to store message (http)", "thread", threadIdx, "index", m, "error", err)
			return
		}
		keys = append(keys, key)
	}
}

func computeDepthHTTP(keys []string, parent string) int {
	for i := len(keys) - 1; i >= 0; i-- {
		if keys[i] == parent {
			return len(keys) - 1 - i
		}
	}
	return 0
}

// headers := optional extra headers map
func postDataHTTP(serverAddr string, auth *httpAuth, content []byte, mime, parent string, headers map[string]string) (string, error) {
	var body bytes.Buffer
	writer := multipart.NewWriter(&body)
	partHeader := make(textproto.MIMEHeader)
	partHeader.Set("Content-Disposition", `form-data; name="file"; filename="payload"`)
	partHeader.Set("Content-Type", mime)
	part, err := writer.CreatePart(partHeader)
	if err != nil {
		return "", err
	}
	if _, err := part.Write(content); err != nil {
		return "", err
	}

	// metadata
	metadata := map[string]any{}
	if parent != "" {
		metadata["parent"] = parent
	}
	if len(metadata) > 0 {
		metaBytes, _ := json.Marshal(metadata)
		_ = writer.WriteField("metadata", string(metaBytes))
	}

	if err := writer.Close(); err != nil {
		return "", err
	}

	// construct token and nonce
	tokenPlain := []byte("auth:" + fmt.Sprintf("%d", time.Now().UnixNano()))
	tokenNonce := make([]byte, 12) // AES-GCM standard nonce
	if _, err := crand.Read(tokenNonce); err != nil {
		return "", err
	}
	tokenCipher, err := encryptAESGCM(auth.browserKey, tokenNonce, tokenPlain)
	if err != nil {
		return "", err
	}

	req, err := http.NewRequest(http.MethodPost, serverAddr+"/data", &body)
	if err != nil {
		return "", err
	}
	req.Header.Set("Content-Type", writer.FormDataContentType())
	req.Header.Set("X-Auth-KeyHash-Base64", auth.kvHashBase64)
	req.Header.Set("X-Auth-Token", "b64:"+base64.StdEncoding.EncodeToString(tokenCipher))
	req.Header.Set("X-Auth-Nonce", "b64:"+base64.StdEncoding.EncodeToString(tokenNonce))
	for k, v := range headers {
		req.Header.Set(k, v)
	}

	resp, err := auth.client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusCreated {
		b, _ := io.ReadAll(resp.Body)
		return "", fmt.Errorf("failed to POST /data: status=%d body=%s", resp.StatusCode, string(b))
	}
	var result struct {
		Key string `json:"key"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}
	return result.Key, nil
}

func encryptAESGCM(key, nonce, plaintext []byte) ([]byte, error) {
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	a, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}
	return a.Seal(nil, nonce, plaintext, nil), nil
}

func computeDepth(keys []cryptHash.Hash, parent cryptHash.Hash) int {
	for i := len(keys) - 1; i >= 0; i-- {
		if keys[i] == parent {
			return len(keys) - 1 - i
		}
	}
	return 0
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
